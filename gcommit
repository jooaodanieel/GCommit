#!/usr/bin/env python
from __future__ import print_function
import argparse
import os
import sys
import tempfile
from subprocess import call, check_output, CalledProcessError

def format_developer(line):
    """
    Team members must be written as
    ID="Member Name <member.email@example.com>"
    ID2="Member Name 2 <member2.email@example.com>"
    ID3="Member Name 3 <member3.email@example.com>"
    """
    return line.replace("\n", "").strip().split("=")


def format_group(line):
    '''
    A Group of Members must be written as
    GROUP1: ID ID2
    GROUP2: ID ID3
    '''
    group_key, group_value = line.replace("\n", "").strip().split(":")
    group_key = group_key.strip()
    group_value = group_value.strip().split(" ")
    return (group_key, group_value)

def check_format(str_array):
    return len(str_array) == 2


def read_config_file():
    try:
        team = {}
        groups = {}
        curr_dir = os.getcwd()
        team_file = "{}/.gitteam".format(curr_dir)
        with open(team_file) as f:
            for i, line in enumerate(f):
                # Seek for Members
                if '=' in line:
                    dev = format_developer(line)

                    if check_format(dev):
                        team[dev[0]] = dev[1]
                    else:
                        raise SyntaxError("Format error .gitteam:{}".format(i + 1))
                # Seek for Groups
                elif ':' in line:
                    group = format_group(line)

                    if check_format(group):
                        groups[group[0]] = group[1]
                    else:
                        raise SyntaxError("Format Group error .gitteam:{}".format(i + 1))

        return (team, groups)

    except IOError:
        raise IOError('Could not find .gitteam file')


def filter_team(team, initials):
    filtered = {}

    error = None
    for mem in initials:
        if mem in team:
            filtered[mem] = team[mem]
        else:
            error = "Identifier '{id}' not found".format(id=mem)
            break

    msg = "Identifiers must match those in .gitteam file"
    if error:
        raise ValueError("{} - {}".format(msg, error))
    if len(filtered) == 0:
        raise ValueError(msg)
    return filtered


def commit():
    call(["git", "commit", "-s"])


def group_commit(team):
    initial_message = b"\n"

    for d in team:
        line = "\nSigned-off-by: {}".format(team[d])
        initial_message += line.encode()

    try:
        editor = check_output(['git', 'config', 'core.editor'])
        editor = editor.decode().strip()
    except CalledProcessError:
        editor = os.environ.get('GIT_EDITOR', 'nano')

    with tempfile.NamedTemporaryFile(suffix=".tmp") as tf:
        tf.write(initial_message)
        tf.flush()
        try:
            print(editor, tf.name)
            call([editor, tf.name])
        except OSError:
            print('Error: Editor {} not found'.format(editor))
            print("Configure the editor by setting the 'GIT_EDITOR' env variable")
            print("Or by setting 'git config --global core.editor {editor}'")
            sys.exit()
        tf.seek(0)
        edited_message = tf.read()
        call(["git", "commit", "-m", edited_message])


def main():
    """
    Tries to create a multi-dev commit signature
    If there's no .gitteam file, then a regular commit is done
    If there's an argument-format error, then a ValueError is raised
    """

    # Define expected command line arguments, and parse arguments given
    parser = argparse.ArgumentParser(
        description='GCommit is a git-plugin that allows commits to be signed \
                    by more than one person -- pair and mob programming \
                    reality.')
    parser.add_argument(
        'initials', metavar='[INITIALS]', type=str, nargs='+',
        help='The intials of each developer defined in .gitteam')
    args = parser.parse_args()

    try:
        team, groups = read_config_file()
        
        # Verify if a Group is on args
        for arg in args.initials:
            if arg in groups.keys():
                # If it is, remove it from args and append each group member...
                args.initials.remove(arg)
                for member in groups[arg]:
                    args.initials.append(member)

        group = filter_team(team, args.initials)
        group_commit(group)
    except ValueError as ve:
        print(ve)
    except OSError:
        commit()
    except SyntaxError as se:
        print(se)


if __name__ == "__main__":
    main()
